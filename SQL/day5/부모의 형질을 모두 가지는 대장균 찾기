SELECT C.ID, C.GENOTYPE, D.GENOTYPE AS PARENT_GENOTYPE FROM ECOLI_DATA C
JOIN ECOLI_DATA D ON C.PARENT_ID = D.ID 
WHERE(C.GENOTYPE & D.GENOTYPE) = D.GENOTYPE
ORDER BY ID ASC

셀프조인 너무 어렵다...
LEFT JOIN은 처음 컬럼이 메인이 돼서 두 컬럼이 일치하는 값이 없더라도 왼쪽 컬럼을 다 보여준다.

1. JOIN vs LEFT JOIN: "누구를 버릴 것인가?"
이것만 기억하세요. "부모가 없는 데이터(NULL)를 결과에서 뺄 것인가, 말 것인가?"
INNER JOIN (또는 그냥 JOIN): "조건에 안 맞으면 다 버려!"
부모 ID가 없는 '최초의 조상 대장균'은 부모 형질과 비교할 수 없죠? 그래서 이들은 결과에서 삭제됩니다. (문제에서 '부모의 형질'을 물었으니 부모 없는 애들은 필요 없으니까요.)
LEFT JOIN: "왼쪽에 있는 건 일단 다 보여줘!"
부모가 있든 없든 왼쪽(자식) 테이블에 있는 모든 대장균을 다 출력합니다. 부모 없는 애들은 부모 형질 칸이 NULL로 표시되겠죠.
결론: 비교할 대상이 양쪽 테이블에 둘 다 확실히 있을 때만 보고 싶다면 JOIN, 한쪽이 없더라도 일단 다 나열하고 싶다면 LEFT JOIN을 씁니다.

2. 이름이 다른 컬럼을 묶는 법: "이름이 아니라 '의미'를 보세요"
SQL에서 ON 뒤에 오는 조건은 이름이 달라도 상관없습니다. 데이터의 '의미'만 같으면 됩니다.
이번 문제를 다시 예로 들어볼게요:
자식 테이블(C)의 행에는 "내 부모가 누구인지" 적힌 PARENT_ID 칸이 있습니다.
부모 테이블(P)의 행에는 자기 자신의 번호인 ID 칸이 있습니다.
우리가 연결하고 싶은 건 "자식의 부모 번호와 부모의 실제 번호"입니다.
그래서 C.PARENT_ID = P.ID라고 쓰는 것입니다.
예시 (이름이 달라도 조인되는 경우):
회원.아이디 = 주문.구매자계정 (성공!)
국가.코드 = 도시.소속국가이름 (성공!)
이름이 같아야만 하는 게 아니라, 두 칸에 들어있는 값이 서로 연결되는 값이기만 하면 됩니다.
